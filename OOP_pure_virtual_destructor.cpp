#include <iostream>
#include <string>

using namespace std;

// Чисто виртуальный деструктор
// Чисто виртуальный деструктор похож на чисто виртуальные функции
// Если мы создаём чисто виртуальную функцию, то такой класс автоматически становится абстрактным
// Тоже самое происходит и при объявлении чисто виртуального деструктора - в дальнейшем мы не сможем создать объект класса, в котором объявили такой деструктор
// Абстрактный класс создается для того, чтобы мы могли работать с любыми его наследниками по ссылке на метод абстрактного класса
// Не имеет смысла делать класс абстрактным, если в нем реализованы все необходимые нам методы

class A
{
    public:
        A()
        {

        }
        // Чисто виртуальный деструктор
        virtual ~A() = 0;
};

// Запись ниже предотвращает ошибку при компиляции, которая объясняется следующим образом:
// Указатель на базовый класс A ссылается на класс своего наследника B 
// В момент использования ключевого слова delete и очистки динамической памяти, на которую указывает указатель bptr, у нас вызывается сначала деструктор класса B, а затем компилятор попытается вызвать деструктор базового класса А
// Но так как в деструкторе базового класса А нет никакой реализации, то это вызывает ошибку
A::~A() {};

class B : public A{
    public:
        B()
        {

        }
        ~B() override{

        }

};

int main()
{
    setlocale(LC_ALL, "ru");

    // Компилятор не позволяет создать экземпляр объекта класса А
    // Следовательно, наш базовый класс является абстрактным, а деструктор класса А - чисто вирутальным
    // A a;

    A *bptr = new B;

    delete bptr;

    return 0;
}