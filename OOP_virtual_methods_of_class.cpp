# include <iostream>
# include <string>

using namespace std;



/*
    Полиморфизм
    Виртуальные функции
    Virtual
    Override
*/

// Виртуальные функции один из способов реализации полиморфизма. С помощью таких функций мы можем описать какой-либо класс, который будет исполнять какой-то опредленный код
// Далее, от этого класса мы можем унаследовать какой-то другой класс и определить поведение этого класса с использованием тех же самых методов, что были в базовом классе, иным образом
// То есть классы имеют одни и те же методы, но ведут себя по разному - в это заключается смысл полиморфизма
// По сути объекты тех классов, которые мы будем создавать, будут сами определять свой функционал

// Для более простого примера рассмотрим класс "пистолет", в котором реализован метод "выстрелить"
// Допустим, наш пистолет стреляет только одиночными выстрелами
// Далее нам необходимо реализовать класс "пистолет-пулемет", который также имеет метод "выстрелить", однако он реализован иначе
// Для этого от класса "пистолет" мы можем унаследовать класс "пистолет-пулемет" и переопределить в нем метод "стрелять"
// Как итог мы имеем два взаимосвязанных класса - пистолет и пистолет пулемет

class Gun
{
    public:
        // Добавление модификаторы virtual
        virtual void shoot()
        {
            cout << "Shoot x1" << endl;
        }
};

class SubMachineGun : public Gun
{
    public:
        // override - пишется для преопределения функции. Позволяет сохранять сигнатуру метода от первоначального метода
        // ключевое слово override было добавлено, чтобы компилятор контролировал то, как переопределяется функция
        void shoot() override
        {
            cout << "Shoot x5" << endl;
        }
};

class LightMachineGun : public Gun
{
    public:
        // override - пишется для преопределения функции. Позволяет сохранять сигнатуру метода от первоначального метода
        // ключевое слово override было добавлено, чтобы компилятор контролировал то, как переопределяется функция
        void shoot() override
        {
            cout << "Shoot x100" << endl;
        }
};


class Player{
    public:
        // Главное отличие состоит в том, что метод игрока принимает в себя переменную, а именно указатель  
        void shoot(Gun *gun)
        {
            gun ->shoot();
        }
};

int main()
{
    Gun gun;
    gun.shoot();
    SubMachineGun machineGun;
    LightMachineGun L_star;

    // Указатель базового класса может ссылаться либо на объект того же класса, либо на любой другой класс, который унаследован от него, то есть на объект класса SubMachineGun
    // Это дает нам возможность по указателю на базовый класс вызвать метод shoot(), но уже с реализацией в классе-наследнике
    // В случае вызова следующего закомментированного кода, будеи использован метод с реализацией в базовом классе - в этом и заключается полиморфизм

    // Gun *weapon = &TT;
    // weapon -> shoot();

    // Указатель
    Gun *weapon = &machineGun;
    // Обращение через указатель, который содержит в себе ссылку на объект класса, у которого мы вызываем метод shoot()
    weapon -> shoot();

    // Пример использования 
    // В случае, если бы мы не использовали виртуальные функции, нам бы пришлось для каждого типа вооружения в классе Player писать свою реализацию метода
    Player player;
    player.shoot(&L_star); // Здесь мы можем изменять ссылку, которую передаем в функцию, чтобы использовать разное вооружение. Для эксперимента можно передать &gun либо &machineGun

    return 0;
}