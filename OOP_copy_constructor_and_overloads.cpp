#include <iostream>
#include <string>

using namespace std;

//Перегрузка оператора равенства 
//По умолчанию оператор равенства не реализован
//Перегрузка оператора сложения
//Перегрузка оператора вычитания 
//Перегрузка оператора умножения
//Перегрузка оператора деления
//Перегрузка операторов инкремента и декремента
class Point{
    private:
        int x;
        int y;

    public:
        Point(){
            x = 0;
            y = 0;
            cout << this << "Вызван конструктор класса Point" << endl;
        }

        Point (int valueX, int valueY){
            x = valueX;
            y = valueY;
        }
    //Функция перегрузки оператора равенства
    bool operator == (const Point & other){
        //Краткий вариант сравнения полей объектов класса
        //This указывает на объект, который сравнивается
        //other указывает на объект, с которым сравнивают
        return this -> x == other.x && this -> y == other.y;

        //Полный вариант того, что написано выше
        // if(this -> x == other.x && this -> y == other.y){
        //     return true;
        // }
        // else{
        //     return false;
        // }
    }

    //Функция перегрузки оператора неравенства
    bool operator != (const Point & other){
        return !(this -> x == other.x && this -> y == other.y);
    }

    //Функция перегрузки оператора сложения 
    Point operator + (const Point & other){
        Point temp;
        temp.x = this -> x + other.x;
        temp.y = this -> y + other.y;
        return temp;
    }

    //Функция перегрузки оператора вычитания
    Point operator - (const Point & other){
        Point temp;
        temp.x = this -> x - other.x;
        temp.y = this -> y - other.y;
        return temp;
    }

    //Функция перегрузки оператора умножения
    Point operator * (const Point & other){
        Point temp;
        temp.x = this -> x * other.x;
        temp.y = this -> y * other.y;
        return temp;
    }

    //Функция перегрузки оператора деления
    Point operator / (const Point & other){
        Point temp;
        temp.x = this -> x / other.x;
        temp.y = this -> y / other.y;
        return temp;
    }

    //Функция перегрузки префиксного оператора инкремента
    Point & operator ++(){
        this -> x += 1;
        this -> y++;

        return *this;
    }

    //Функция перегрузки постфиксного оператора инкремента
    //Главное отличие заключается в том, что в случае постфиксного инкремента
    //мы передаем значение переменной в функцию перегрузки. 
    //То есть данное передаваемое значение переменной необходимо только для различия вызываемых функций
    Point operator ++(int value){
        Point temp(*this);//Создание временного объекта, над которыми мы будем проводить дальнейшие операции
        this -> x++;
        this -> y++;

        return temp;
    }

    //Функция перегрузки префиксного оператора декремента 
    Point & operator --(){
        this -> x--;
        this -> y--;

        return *this;
    }

    //Функция перегрузки постфиксного оператора декремента
    Point operator --(int vlaue){
        Point temp(*this);
        this -> x--;
        this -> y--;

        return temp;
    }

    void SetX(int x){
    }
    int GetX(){
        return x;
    }
    void SetY(int y){
    }
    int GetY(){
        return y;
    }
};

//Конструктор копирования
//Перегрузка оператора присваивания
//Перегрузка операторов равентсва и неравентсва
class MyClass{
    private:
        int arraySize;

    public:
        int *data;
    
    MyClass(int size){
        this -> arraySize = size;
        this -> data = new int[size];
        for( int i = 0; i < size; i++){
            data[i] = i;
        }
        cout << "Вызвался конструктор " << this << endl;

    };
//Конструктор копирования по ссылке
    MyClass(const MyClass &other){
        this -> arraySize = other.arraySize;//передаем переменную Size, так как она приватная
        this -> data = new int[other.arraySize];//присваиваем новому массиву размер старого массива
        for(int i = 0; i < other.arraySize; i++){
            this -> data[i] = other.data[i];//в новый массив копируем данные из старого массива
        }
        cout << "Вызвался конструктор копирования " << this << endl;
        
    }
//Метод перегрузки оператора присваивания
//Перегрузка должна быть функцией с возвращаемой переменной, причем разыменованной
    MyClass & operator = (const MyClass &other){
        cout << "Вызвался оператор присваивания " << this << endl;

        this -> arraySize = other.arraySize;

        //Для общих случаев очистки памяти
        if(this -> data != nullptr){
            delete[] this -> data;
        }

        //delete[] this -> data;//работает для освобождения памяти из-под динамического массива

        this -> data = new int[other.arraySize];
        for(int i = 0; i < other.arraySize; i++){
            this -> data[i] = other.data[i];
        }

        return *this;
    }

    ~MyClass(){
        cout << "Вызвался деструктор " << this << endl;
        

        delete[] data;
    };
};

//Перегрузка оператора индексирования
class IndexOverload{
    public:
        int & operator[](int index){
            return arr[index];
        }
    private:
        int arr[5]{5, 44, 4, 987, 69};
};

//Передача параметра по значению
//При передаче параметра по значению у нас внутри нашей функции создается новая переменная, того типа, которой мы принимаем парметры 
//И данные из той переменной, которую мы передаем в эту функицию копируются в ноую функцию
//Поэтому изменения новой переменной не повлияют на первоначальную переменную

//По умолчанию выполняется копирование по умолчанию
void Foo(MyClass value){
    cout << "Вызвана функция Foo1 " <<endl;
}

MyClass Foo2(){
    cout << "Вызвана функция Foo2 " <<endl;
    MyClass temp(2);

    return temp;
}

int main(){

    setlocale(LC_ALL, "ru");

    //Foo2();
    MyClass a(10);
    //MyClass b(a);//для конструктора копирования
    MyClass c(2);
    MyClass d(5);
    

    a = c = d;

    //Перегрузка операторов равенства и неравенства
    Point z(5, 1);
    Point x(5, 1);
    Point v(5, 1);
    bool result = z == x;//сравнивание объектов класса z и x для проверки перегрузки оператора равенства
    bool result1 = z != v;//сравнение объектов класса v и x для проверки перегрузки оператора неравенства

    //Перегрузка оператора сложения
    Point zx = z + x;

    //Перегрузка оператора вычитания
    Point qw = z - x;

    //Перегрузка оператора умножения 
    Point as = z * x;

    //Перегрузка оператора деления
    Point rt = z / x;

    //Перегрузка префиксного оператора инкремента
    Point t(1,1);
    ++t;
    Point m = t;

    //Перегрузка постфиксного оператора инкремента
    Point h(2,2);
    Point j = h++;

    //Перегрузка префиксного оператора декремента
    Point o(1,1);
    --o;
    Point p = o;

    //Перегрузка постфиксного оператора декремента
    Point n(3,3);
    Point g = n--;

    //Перегрузка оператора индексирования 
    //Работает следующим образом: мы не обращаемся к элементу массива напрямую. Вместо этого мы обращаемся к объекту класса.
    //В момент вызова перегруженного оператора индексирования мы попадаем в функцию класса. 
    //Эта функция получает переменную, содержащую информацию об индексе, к которому мы хотим обратиться, а затем возвращает элемент под этим индексом из этого массива
    //Подобный функционал используется для реализации объектов типа вектор в библиотеке stl
    IndexOverload test;
    cout << test[1] << endl;

    //При реализации перегрузки оператора индексирования мы возвращаем значение по ссылке
    //Это сделано для того. чтобы в дальнейшем мы могли присвоить другое значение элементу массива, обратившись к нему по индексу
    //Значение по ссылке на определенный элемент массива можно изменить, а в случае, если мы уберем & из реализации функции перегрузки оператора индексирования,
    //то мы будем работать с копией, которую не сможем изменить
    //Пример представлен ниже
    test[1] = 100;
    cout << test[1] << endl;


    // MyClass c(2);//для переполнения оператора равенства
    
    // a = c; - error

    //Foo(a);

    return 0;
}
