#include <iostream>
#include <string>

using namespace std;

// Виртуальный деструктор
// Виртуальный деструктор позволет избежать утечек памяти


// В данном уроке динамическая память не выделяется, так как при реализации выделения динамической памяти сложно отследить момент утечки памяти
// Вместо этого для наглядности используются функции cout, которые в терминале сообщают об определнных событиях 
class A
{
    public:
        public:
        A()
        {
            cout << "Выделена динамическая память, Объект класса А" << endl;
        }
        virtual ~A()
        {
            cout << "Освобождена динамическая память, Объект класса А" << endl;
        }


};

class B : public A
{
    public:
        B()
        {
            cout << "Выделена динамическая память, Объект класса Б" << endl;
        }
        ~B() override
        {
            cout << "Освобождена динамическая память, Объект класса Б" << endl;
        }
};


int main()
{
    setlocale(LC_ALL, "ru");

    // Данный код вызывает утечку памяти, так как не происходит освобождения памяти из-под объекта класса Б
    // Это происходит из-за того, что деструктор базового класса не являлся виртуальным
    // Поэтому в момент освобождения памяти компилятор посмотрел на тип указателя bptr (тип указателя A) и освободил память только из-под объекта класса А
    // Пример ошибочного кода ниже 
    
                // A *bptr = new B;
                // delete bptr;

    // Чтобы этого избежать необходимо использовать ключевое слово virtual при реализации деструктора базового класса А
    // А также необходимо использовать ключевое слово override в классе-наследнике B при определении деструктора
    // После реализации виртуального деструктора вызывается и переопределенный деструктор класса Б, и деструктор базового класса А
    A *bptr = new B;
    delete bptr;


    return 0;
}